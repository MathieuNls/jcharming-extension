Editorial Board Member
Comments to the Author:
The reviewers appreciate the research conducted by the authors and believe the approach proposed to be promising. However, the submission requires a major revision before it can be accepted for publication. Specifically, the authors should improve on the following points:
* formal definitions and notations (Reviewers 1 and 2)
* usability of the approach: are the traces found the shortest ones possible (Reviewer 2), optimality of the solution (Reviewer 2) and its limitations (Reviewer 1)
* improving the discussion: shortening/improving Section 6 (Reviewer 1), elaborating on "directed model checking" (Reviewer 2) and comparing the approach proposed with the existing solutions (Reviewer 2).

Referee(s)' Comments to Author:

Reviewing: 1

Comments to the Author
SUMMARY

This paper presents an approach for bug reproduction that is based on model checking. Given a crash trace and a violated boolean property, the model checker is queried in a way so that it returns a counter example that corresponds to a path in the program from the entry to the crash location. The authors have developed a tool, JCHARMING, that chains WALA, Java Pathfinder, and a newly written generator for JUNIT tests. WALA helps reducing the program state space by reducing the program to a slice along the exceptional control flow, while the JUNIT generator provides the human tester with a reproducible bug.

The techniques themselves are not new, but their combination and application to the problem of bug reproduction is novel and quite promising. I recommend acceptance, but feel a few improvements are in order, namely

- proving a formal definition of the syntax of traces;
- proving a formal definition of a frame and a slice and a better discussion ("reasoning") of the algorithm;
- extending or modifying the evaluation section by a complete characterization
  of the partially and not reproduced bugs in the 30-x cases (table)
- identifying, and making explicit, the limitations of JCHARMING

The review instructions also ask for possibilities for condensing (or amplifying) the text. In my opinion, the prose in section 6 could be shortened.

For more details, see below.


DETAILED COMMENTS
Page 2
l.16 "In [7]": poor style (writing rules say that the sentence must be complete if you leave out the reference), also see l.40
->math:done

l.21 "uses a list of function outputs": every output comes from a function
-> be more specific. Also, make clear that JCHARMING additionally uses the source code.

->math: reviewer didn't get the meaning of the sentence here. output WHEN an uncaught...

l.28 "control flow graph" seems a bit misleading since there is
no 1-1 correspondence between statements in the source and program states.
->math:??

l.38 "Hadoop and, " -> Hadoop, and
->math:done

l.43 systems are "relatively complex": you contradict yourself a bit here,
since, at least for complex bugs, you write in Section 7 that the quality of
the trace is what matters.

->math: fixed by larger. Yes, the quality of trace is important, but the size of the
remaining slice is even more important


Page 3
l.29 "NP-complex" does not exist as technical term IMO.
A problem can be "NP-complete" or in the "complexity class@ NP.
->math:

l.35-39: don't you mean that it is _im_possible to reproduce the bug?
->math: Not impossible, one could create an approach that re-create a network packet
based on the crash characteristics.

What does "specific data" refer to---simply the input?
->math:

Page 4
l.08 "minimal"... what?
->math:clear to me

l.39 typo in "JRapture"
->math:done

l.42 "and on the replay": grammar
->math:done

Page 5
l.03 "code-level" delete hyphen
->math:done

l.03 ", there exist": put in a new sentence
->math:done

l.28 "stack" -> stacks
->math:Looks good to me

l.33 "prior to the work ... begins": grammar
->math:done

l.34 add a period after "i.e."
->math:done

Page 6
l.42 "P is the set of properties that each state satisfies":
incorrect or at least misleading scope of "the set."
You mean "P associates with each state the set of properties that it satisfies."
->math:done


l.47 what exactly is "x": a state or a _sequence_ of states (path)?
I am familiar with the former, i.e., the situation where one asks
the model checker whether property p holds in state x of model M,
and then might get back the trace that constitutes a counter example.
If "x" really is a path, then, for example,  "x \in S" (Eq. 1) wouldn't hold,
since $S$ is a set of states. Also, in Eq. (3), you would quantify
over paths rather than states.

->math: It's a state

l.52 "specification" is not a good term here (and has a different meaning
in formal methods), do you mean additional assumption?
->math:done


l.52 just as a remark, "fairness" has a special meaning in (LTL) model checking.
->math:noted

Page 7
l.17 "depicts" -> depict
->math:done

Page 8
l.51 "are" -> is
->math:done

Page 9
I don't understand Figure 5. Why is there a call to Foo.bar
(even though in Figure 1 there is no edge from Bar.foo to Foo.bar)?
What is "looptimes" - in Figure 1, the bound is called "loopCount"?

->math: This is the result of the String constructor of InvalidActivityException in
java i.e. throw new InvalidActivityException("loopTimes");

Where is the call to Bar.foo the "crash trace contains" (l.23).
->math: In the "and 4 more"

Generally, I strongly recommend to include a grammar of a trace;
this would also help answering some of my later questions (see below).

l.38 typo in the caption; I would also reformat the caption to avoid the lonely "2."
->math: done


l.42 what exactly is a frame? Put differently, what is the difference between a
line number in a trace and a frame?
Does f_0 have to contain a property (in terms of a programming language:
an expression), as Figure 5 and p. 12 suggest, or does it have to contain
an exception?

->math: As shown in Figure \ref{fig:jcarming-traces}, we can see that the first line (referred to
as frame {\it $f_0$} , subsequently the next line is called frame {\it $f_1$} , etc.)

l.46 "buggy ": delete the extra blank.
->math: done

Page 10
l.17 delete the extra "the."
->math: done

l.21 "out of control" -> beyond control
->math: done

l.48 I am not sure whether I completely understand what a slice is in your
context: does a slice consist of statements and declarations
from the program source? And do frames constitute slicing criteria,
or (since this wouldn't work) phrased more precisely: the method invocation
 they contain? Please provide a formal definition of a slice.

->math: Definition is fine to me



l.54 typo in f_{n 1}
->math: done

l.55 in my understanding of a slice, the order of statements is essential,
especially if the slice has to remain executable.
Rather than forming the union of slides, you should therefore, e.g.,
concatenate them. (Perhaps the implementation is based on a union that happens
to preserve the order, so that you never faced the difference between a set
and a sequence). Algorithm 1 needs to be changed accordingly.


Page 11
l.09 "allow to reach": grammar

->math: done

Figure 6: what is "entry"? What is the purpose of the two self-loops in z0 and
z1?

->math: Entry is the entry point of the program, i.e. the main in Java.
->math: No purposes in particular, self-loops do happens

l.31 as a comment, the "worst case scenario" is the best-case scenario from the
perspective of state space explosion...

->math: noted


l.44 how can a slice be empty? Since there is an underlying execution between
frame f_i and f_{i+1}, there have to be program statements, no?
Again, a definition of a slice would have helped me (perhaps).
I also didn't understand why "offset" is reset to 1 in Algorithm 1.

l.48 "would": is colloquial

->math: ??

l.55 comma after WALA[31]

->math: done


Page 12
l.6-l.14 what is the point in this paragraph? "At first sight, it may appear
that static slicing alone be used..."... OK, and what at second sight?

->math: This is in the text

l.20 "frame" -> frames

->math: didn't find it

l.24 shouldn't "i+offset" be frames[i+offset]?
Algorithm 1: shouldn't the slicing criterion change in each iteration of the loop?


l.40, Eq.(6): I need some clarification on the premise of \models: assuming "x"
is a path, what does "x." mean? Also, SUT and the union of slides are quite
different types, why is it legal for both to write "x."?
Further, what is the first subset relation good for
(the one without the "x"-qualification)?
Please introduce the notation and explain the different terms formally.

l.45 What do you mean by "c_{i>1}" needs to be included"? Is this an
extra step or does the slicer find that "c_{i>1}" automatically?
And why can one include expressions anyway? Doesn't the slice contain statements?

l.46 "needs to be untouched": I can't follow

Page 13
l.05 delete comma after "each"

->math: done

l.10 delete "entry"
->math: done


l.11 typo in s_i+1

->math: ???

l.16 "As shown before": where?
->math : in fig6. fixed

Page 14
l.48 "an hypothetical" -> a hypothetical
What are the limitations of the unlowering steps? Which parts can you not
reconstruct? Please make explicit.

Page 15
Figure 8: faillure -> failure (3x)

->math: done

l.49 "Kilo Line": I've never seen KLoC spelled out like this.

->math: that's standard

l.52 "make files": shouldn't it be Makefiles?

->math: fixed

Page 15
l.22 "player in" -> player among

->math: fixed

l.55 "built on the top" -> built on top

->math: fixed

l.56 "that" -> , which
->math: fixed

Page 19
l.08, l.09: delete blanks before the setTarget... method (line 3 and 4 in
trace, also in the trace on page 22)

->math: fixed

Page 20
l.38: add comma after "class"
Removal of lines in the preprocessing step could also mean that
variables relevant for control- or data dependence are not discovered, correct?
This could then cause problem in the construction of test cases, correct?

Page 21
Both cases in Section 6.2 I don't find particularly enlightening.
Surely, not match-able segments of traces present problems,
but that is hardly surprising.
Besides, in the second case, JCHARMING could employ a different
definition of equality and in the first case include a heuristic.
Instead of discussing what is more or less obvious, it  would be much
more interesting to count the frequency of those cases.
Or to cluster resp. classify them, or to discuss how JCHARMING could
improve its precision.
Asked differently, what characterizes the "quality of ... crash trace"
you refer to on page 23?

Several bug reports contain spelling mistakes (the two reports on page 21
contain 2 resp. 1 typo, the one on p.22f. another one). Are those in the original
reports? (If so I'm not sure if one is allowed to correct them.
Please inform yourself and get back to me :-)

Page 22
l.42-46 I can't follow your argumentation: why did JCHARMING not find the crash
location? What is different in the case of Struts?

-> Because the SUT was Log4J and the error belongs to struts.

l.47 capitalize log4j
->math: fixed
l.50 add comma after 46721
->math: fixed

l.50/51 "We believe that JCHARMING could have successfully..":
why don't you just try it? Is it so complicated to rerun JCHARMING?

->math: the generated exception do not belong to struts. Only the entry point
is from struts. We all have to do an undirected model checking here.

Page 23
l.27 add an "a" before "program's behavior"

->math: done

l.50-54: correct, certain failures are "hardly reproducible."
What to conclude, though?

Page 24
l.24 "bug" -> bugs

->math: done

References (plenty of problems):
Capitalization inconsistent in conference titles (e.g., [1,2,3,4])
Capitalization wrong in first names, tools, etc (e.g, [8,17,19])
Problems with non-ASCII letters (e.g., [15,25])
Incomplete reference (e.g., [14,17])

Reviewing: 2

Comments to the Author
The authors present a technique to reproduce program crashes by using a combination of backward slicing and (directed) model checking.
The information obtained in the backward slicing operation serves as a way to guide the model checking activity. The approach is interesting,
and reasonably well explained, but the formal aspects need to be improved. Whenever formal notations are used, I got quite confused by the inconsistencies
that are currently in the text (see my detailed comments). I also would have liked to learn more about the way properties are expressed.
This is not explained at all in the current text.

Regarding the directly related work, I think the authors give a nice overview, but with respect to "directed model checking", the authors do not explain its origins at all (again, see detailed comments).

The main benefit of model checking over testing is its ability to determine that a system is absolutely correct. By starting with a bug and guiding the
checking to it, you are essentially not model checking anymore, but bug hunting. Of course, directed model checking in a way depends on there being a bug,
otherwise is devolves into traditional model checking. A discussion along those lines should be added, I think, to make this clear to the reader, since
"model checking" usually has this completeness characteristic of being able to show that a system is correct.

Can you say anything regarding the length of your counter-example traces? For understandability, it is crucial that counter-examples are short. It would
be interesting to know whether JCHARMING tends to produce the shortest counter-example or not, and if not, whether you could alter the technique to improve
this.

Can you produce results that show to what extent your approach is optimal? How many states were visited vs. how many absolutely need to be visited to find
the counter-example? Experiments like that would give an indication how well JCHARMING is able to find the counter-example based on the backward slice information.

Concluding, I think the article is promising and presents interesting results. However, I think the formal aspects need to be improved, and some more insight
could be given regarding the effectiveness of the approach.


Detailed comments:

Page 1:

- piece -> pieces

->math: Piece is correct, THE most

Page 2:

- functions output -> function outputs

->math: done

Page 3:

- oversee -> oversees

->math: done

- a NP-Complex -> an NP-complete

->math: done

- different SMT (satisfiability modulo theories) solvers: different from what?

- model checking techniques: SMT is being used for model checking itself,
 so the "even" remark seems to be odd. Why is it so strange that these are proposed?

- For example, the reading of a file that is only present on the
hard drive of the customer or the reception of a faulty network packet:
This is not a complete sentence.
Please complete it or attach it to the previous sentence.

- reproduce a crash to be purely external.: so, is
it possible to reproduce the crash / bug or not? You seem to indicate both.

- for bug reproduction systems: also in [4], or in other papers?

Page 4:

- file whose size averages 70KB -> files that are 70Kb on average

->math: done

- Similarly, private: similar to the approach of Clause et al.?
Please mention this

->math: ???

- clones: remove s

->math: done

- JRaptrue -> JRapture

->math: done

- creator -> creators

->math: done

- it saw -> as

->math: done

- phase: a proper ending of this sentence is missing, e.g. "are presented"

->math: ???

- that can also monitor other software system than the intended ones:
why is that a problem?

- system -> systems

->math: which one ?

Page 5:

- level, there -> level. There

->math: done

- lies: relies?

->math: done

- really begins -> really beginning

->math: Sounds good to me

Page 6:

- used based -> based

->math: done

- Except for STAR: so how does JCHARMING compare to STAR?

- the system: for model checking, it is crucial to mention that the system
is formally defined (has a clear semantics)

- P is the set of properties that each state satisfies ->
 P is a set of state predicates, and there should be a
function assigning subsets of P to states.
Typically, however, P does not hold in its entirety in all reachable states

- The SUT is said to satisfy a set of properties:
you seem to give a definition here of satisfying a property
that corresponds with testing.
 For model checking, a property is said to hold if there exists
 no trace contradicting it.

- not that p holds nor that ∀x, p is satisfiable: if that is the case,
then the system does not satisfy p.

- fair environment: is there any relation to fairness in formal verification,
as in "Behaviour that is infinitely often enabled is also infinitely often executed"?

- properties: How are the properties expressed, using which temporal logics?

Page 7:

- (3): this is closer to satisfying a property in a model checking context.
Usually, the "for all x" does not need to be added though.
In fact, the shorter notation SUT |= p would be more in line with what is common

- such a path exists -> there exists a path contradicting this

- depicts -> depict

->math: done

Page 8:

- what to look for in order to detect the causes: do you mean intermediately,
 i.e. along the trace? Because the final goal is known here (i > 2)

- complete, but impractical: that depends on the search order, which,
as you mention later, opens the door for directed model checking

- directed (or guided) model checking has been introduced [28]:
actually, the term "directed model checking" was coined in an earlier paper,
namely "Directed Explicit-State Model Checking in the Validation of Communication
Protocols", by Edelkamp, Leue, and Lluch-Lafuente.
Also, you should refer to "Survey on Directed Model Checking"
by Edelkamp, Schuppan, Bosnacki, Wijs, Fehnker and Aljazzar

- use insights -> uses insights

->math: done

Page 9:

- Figure 5: Bar.Goo -> Bar.Foo. Also, it may improve readability if you add f0, f1 etc to the figure, as you refer to these in the text

->math: done

Page 10:

- that led to the: remove the

->math: sounds right to me

- are not limited to, -> but not necessarily, to

->math:fixed

- also reduce -> reduce

->math:fixed

- foo: previously, "foo" was capitalised. Please be consistent

->math:fixed

- foo: see previous statement

->math:fixed

Page 11:

- equation 5: I have a number of comments regarding (5):

* i ranges from 0 to entry, but f_entry was previously not defined, only just entry
* i should range to entry-1, since otherwise there should also be an f_entry+1, and this appears not to be the case
* equation 4 states that the union equals the bslice from f_0 to entry, here it is a subset. Which one is correct?

- Indeed, in Figure 6, the set of states: based on figure 6,
this set should be empty, as f_2 has no outgoing transitions.
The other sets you mention (f2 to f1 and f1 to f0) are also empty.

- assuming that z2 is a prerequisite: what is a prerequisite?
Which state in figure 6 corresponds with entry?
Why is bslice from f_0 to entry the given set of states?
And the sentence ends prematurely. Which set corresponds
with the union of the given bslices? This example is very confusing.
Please fix this.

- between each frame -> between each two frames

- From line 1 to line 5: in Alg. 1, please number the lines, as you use these numbers in the text. Also the lines in the text are wrong. Instead of "line 1 to 5", you should write "line 1 to 6", and instead of "line 6 and ends at line 15" you should write "line 7 and ends at line 15".

- then JCHARMING: remove then

- the possibility to resort to non-directed model checking: and what if the final slice is not empty? How does it help the directed model checking? This is explained later, but it would improve the text if you already give some indication how this works here.

- provides -> provide

Page 12:

- Frames frames ← extract frames from crash stack;: do not write text in math mode

- size of frame: which frame? Multiple were extracted in previous line. Or do you mean frames?

- equation 6: I have the same issues with this equation as with equation 5. In addition:

* are the two cases between the brackets conjunctives? How are they combined?
* what is the difference between the two cases? How should I read the second one?

- both the transitions and the states are entry elements: how can this be interpreted from the equation?

- That is the -> That is, the

- only frame that needs to be untouched for the backward static slice to be meaningful is f0.: can you elaborate on this? Why is this the case?

Page 13:

- choose -> chose

- each, forward -> each forward

- with entry the states: something is wrong here. Please fix

- that falls -> that fall

- a set a property -> either "a property" or "a set of properties"

- transitions -> transition

- t is the percentage: do not start a sentence with a mathematical symbol

- the exercise of the bug -> execution of the bug, or "the bug to appear"

Page 14:

- industrial size -> industrial sized

- listens the -> listens to the

Page 15:

- a loop from 0 to 3: what do you mean by this?

- as shown in Figure 8.: please discuss figure 8

- study -> studies

- reasonable amount of time: what is a reasonable amount of time?

Page 16:

- time JfreeChart -> time. JfreeChart

- on the top -> on top

- Mahout: in the table, swap the entries for Hadoop and Mahout, to keep it in line with the order in the text

Page 17:

- above t=80%: and below 100%, I assume

- fill out all -> fill all

Page 18:

- dispatching:”: end sentence with '.'

Page 19:

- neither -> either

- nor -> or

Page 20:

- hour -> hours

Page 21:

- ChecksumException Re-running -> ChecksumException. Re-running

- the attached -> of the attached

- While, -> While

- were -> was

Page 22:

- of few -> of a few

- Application -> Applications

- We believe that JCHARMING could have successfully reproduced the crash: couldn't you test this?

Page 23:

- the SUTs analyzed by JCHARMING are the same as the ones used in similar studies: how do the results of JCHARMING actually compare to those obtained in similar studies?

- footnote "described here ... ": make this note a full sentence

Page 24:

- all based on -> all written in

- bug -> bugs

- involves -> involve

- Katoen Jp -> Katoen, J-P.

Page 26:

- 41. Hadoop A. Hadoop 2011.
  42. Mahout A. Scalable machine learning and data mining 2012.
  43. Snyder B, Bosanac D, Davies R. ActiveMQ in Action 2011; :408.: these are not very helpful references. Please add more information
